datasource db {
  provider = "postgresql"
  url      = env("DB_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

model User {
  id                    Int            @id @default(autoincrement())
  createdAt             DateTime       @default(now())
  login                 String         @unique
  password              String
  name                  String
  surname               String
  middlename            String?
  email                 String         @unique
  confirmed             Boolean        @default(false)
  admin                 Boolean        @default(false)
  tutor                 Boolean        @default(false)

  createdCourses        Course[]       @relation("created-courses")
  createdGroups         Group[]        @relation("created-groups")
  participatedGroups    Group[]        @relation("participated-groups")
  participatedCourses   Course[]       @relation("participated-courses")
  createdTasks          Task[]         @relation("created-tasks")
  sentNotifications     Notification[] @relation("user-notification-sent")
  receivedNotifications Notification[] @relation("user-notification-received")
  attempts              Attempt[]
}

enum NotificationType {
  AddedToCourseNotification
  AddedToGroupNotification
}

model Notification {
  id         Int              @id @default(autoincrement())
  createdAt  DateTime         @default(now())
  type       NotificationType

  senderId   Int
  sender     User             @relation("user-notification-sent", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId Int
  receiver   User             @relation("user-notification-received", fields: [receiverId], references: [id], onDelete: Cascade)

  @@delegate (type)
}

model AddedToGroupNotification extends Notification {
  groupId Int
  group   Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
}

model AddedToCourseNotification  extends Notification {
  courseId Int
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
}

model Group {
  id                   Int                        @id @default(autoincrement())
  title                String
  createdAt            DateTime                   @default(now())

  tutorId              Int
  tutor                User                       @relation("created-groups", fields: [tutorId], references: [id], onDelete: Cascade)
  students             User[]                     @relation("participated-groups")
  participatedCourses  Course[]
  addedToNotifications AddedToGroupNotification[]
}

model Course {
  id                   Int                         @id @default(autoincrement())
  createdAt            DateTime                    @default(now())
  title                String
  description          String?

  tutorId              Int
  tutor                User                        @relation("created-courses", fields: [tutorId], references: [id], onDelete: Cascade)
  groups               Group[]
  works                Work[]                      @relation("courses-works")
  students             User[]                      @relation("participated-courses")
  addedToNotifications AddedToCourseNotification[]
  worksStates          WorkState[]
  attempts             Attempt[]
}

model Work {
  id          Int         @id @default(autoincrement())
  title       String
  description String?
  createdAt   DateTime    @default(now())

  inCourses   Course[]    @relation("courses-works")
  tasks       Task[]      @relation("works-tasks")
  attempts    Attempt[]
  states      WorkState[]
  tasksStates TaskState[]
}

model WorkState {
  enabledUntil DateTime?

  workId       Int
  work         Work      @relation(fields: [workId], references: [id], onDelete: Cascade)
  courseId     Int
  inCourse     Course    @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@id([workId, courseId])
}

enum TaskType {
  AgreeTask
  SelectOneTask
  SelectManyTask
  FillGapsTask
  ReplyTask
}

model Task {
  id          Int         @id @default(autoincrement())
  createdAt   DateTime    @default(now())
  title       String
  description String?
  type        TaskType
  tutorId     Int
  tutor       User        @relation("created-tasks", fields: [tutorId], references: [id], onDelete: Cascade)
  inWorks     Work[]      @relation("works-tasks")
  states      TaskState[]

  @@delegate(type)
}

model TaskState {
  disabled Boolean?

  taskId   Int
  task     Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  workId   Int
  inWork   Work     @relation(fields: [workId], references: [id], onDelete: Cascade)

  @@id([taskId, workId])
}

model AgreeTask extends Task {
  correctAnswer Boolean
}

model SelectOneTask extends Task {
  options       String[]
  correctAnswer Int
}

model SelectManyTask extends Task {
  options       String[]
  correctAnswer Int[]
}

// the whole editor instance is stored as json in the db. the answer will be json too, while comparison `SelectOneNode`s contents will be found and compared.
model FillGapsTask extends Task {
  document Json
}

model ReplyTask extends Task {
}

model Attempt {
  createdAt DateTime @default(now())
  studentId Int
  student   User     @relation(fields: [studentId], references: [id], onDelete: Cascade)
  workId    Int
  work      Work     @relation(fields: [workId], references: [id], onDelete: Cascade)
  courseId  Int
  course    Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@id([studentId, workId, courseId])
}

enum AnswerType {
  AgreeAnswer
  SelectOneAnswer
  SelectManyAnswer
  FillGapsAnswer
  ReplyAnswer
}

model Answer {
  id   Int        @id @default(autoincrement())
  type AnswerType

  @@delegate(type)
}

model AgreeAnswer extends Answer {
  answer Boolean?
}

model SelectOneAnswer extends Answer {
  answer Int?
}

model SelectManyAnswer extends Answer {
  answer Int[]
}


model FillGapsAnswer extends Answer {
  // indices of correct answers as array, e.g. [0, 2, 1, undefined, 3] meaning 4th answer left empty
  answer Int[]
}

model ReplyAnswer extends Answer {
  answer Json
}



